require('./public/js/functions.js');
const c = require('./libs/config.js');
const LOG = require('./libs/log.js');
const sha1 = require('sha1');

const globby = require('globby');
const FS = require("fs");
const PATH = require('path');
const HFS = require('./libs/helperFilesystem');
const readdirp = require('readdirp');
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const perms = require('./libs/permissions.js');
perms.load();
const express = require('express');
const compression = require('compression');
const webserver = express();
webserver.use(bodyParser.json()); // support json encoded bodies
webserver.use(bodyParser.urlencoded({extended: true})); // support encoded bodies
webserver.use(cookieParser()); // support cookies
webserver.use(express.static('public'));
webserver.use(compression());

const exifParser = require('exif-parser');

const google = require('googleapis');
const oauth2Client = new google.auth.OAuth2(c.google.clientId, c.google.secret, c.google.redirectUrl);

const sharp = require('sharp');

const start = new Date();
LOG.info('***STARTING***');

try {
	let folderStats = FS.statSync(c.path);
	if (folderStats.isFile()) {
		throw 'it is file';
	}
	let items = FS.readdirSync(c.path);
	if (items.length === 0) {
		throw 'No items in base folder.';
	}
	LOG.info('(Start) Defined base path "' + c.path + '" is valid with ' + items.length + ' items.');
} catch (error) {
	LOG.fatal('(Start) Defined base path "' + c.path + '" is invalid. Error: ' + error);
}

function getUptime() {
	const diff = (new Date() - start);
	return {
		start: start.human(),
		uptime: {
			milliseconds: diff,
			human: msToHuman(diff)
		}
	};
}

/**
 * Middleware for all requests
 * - logging GET and POST
 * - define quick JSON response object
 *
 * @return next()
 */
webserver.all('*', function (req, res, next) {
	let weblog = '';
	weblog += '[' + req.ip + ']';
	weblog += '[' + req.method + ',' + req.protocol + ']';
	weblog += '[' + req.path + ']';
	weblog += '[GET:' + JSON.stringify(req.query) + ']';
	weblog += '[POST:' + JSON.stringify(req.body) + ']';
	LOG.webserver(weblog);

	const requestStart = new Date();

	res.result = {
		datetime: (new Date).human(),
		error: true,
		message: '',
		duration: null,
		result: [],
		setError: function (text) {
			this.error = true;
			this.message = text;
			this.result = [];
			return this;
		}, setResult: function (result, message) {
			this.error = false;
			this.result = result;
			if (message) {
				this.message = message;
			}
			return this;
		}, toString: function () {
			return JSON.stringify(this, null, 4);
		}, end: function() {
			this.duration = msToHuman(new Date() - requestStart);
			res.end(this.toString());
		}
	};
	return next();
});

/**
 * Google logout - just redirect, more info in "/api/logout"
 */
webserver.get('/logout', function (req, res) {
	res.redirect('/api/logout');
});

/**
 * Google login:
 * - redirect to the google login page (if no req.query.code is available)
 * - handling redirect back from Google page (req.query.code is available)
 *
 * @return HTML text if error
 * @return redirect if ok
 */
webserver.get(c.google.redirectPath, function (req, res) {
	res.clearCookie(c.http.login.name);
	let code = req.query.code;
	// Non-logged user (dont have cookie) wants to login. Generate Google login URL and redirect to it.
	// If is login successfull, user will be redirected back with req.code filled
	if (code === undefined) {
		res.redirect(oauth2Client.generateAuthUrl({
			scope: 'email'
		}));
		return;
	}
	code = code.replace('\\', '/'); // Probably bug, backslash has to be escaped
	// User was redirected after success login. Check this code with Google and if is ok, save info about user in
	// file name generated by hash of code
	oauth2Client.getToken(code, function (errGetToken, tokens, response) {
		if (errGetToken) {
			LOG.error('(Login) Error while loading Google token: ' + errGetToken + '. More info in debug.');
			try {
				LOG.debug('(Login) ' + JSON.stringify(response));
			} catch (error) {
				LOG.debug('(Login) Error while parsing response while loading Google token.');
			}
			res.status(500).send('Chyba behem ziskavani google tokenu. Zkus to <a href="/login">znovu</a> nebo kontaktuj admina.<br><a href="/logout">Odhlasit</a>');
			return;
		}
		// Check token and get user email
		oauth2Client.verifyIdToken(tokens.id_token, c.google.clientId, function (errVerifyToken, login) {
			if (errVerifyToken) {
				LOG.error('(Login) Error while verifying Google token: ' + errVerifyToken);
				res.status(500).send('Chyba behem ziskavani google tokenu. Zkus to <a href="/login">znovu</a> nebo kontaktuj admina.<br><a href="/logout">Odhlasit</a>');
				return;
			}
			// Load info about user from Google
			let payload = login.getPayload();
			LOG.info('(Login) Logged user "' + payload.email + '".');
			let tokenHash = sha1(tokens.id_token);

			FS.writeFileSync(c.http.login.tokensPath + tokenHash + '.txt', JSON.stringify({
				logged_time: new Date().getTime(),
				token_id: tokens.id_token,
				token_hash: tokenHash,
				ip: req.ip,
				email: payload.email
			}), 'utf8');
			res.cookie(c.http.login.name, tokenHash, {expires: new Date(253402300000000)});
			res.redirect('/');
		});
	});
});

/**
 * Main API middleware:
 * - validate login cookie (if user logged)
 * - load (default) user and password permissions
 *
 * @returns next()
 */
webserver.get('/api/[a-z]+', function (req, res, next) {
	// Load default user permissions
	let userPerms = perms.getUser('x');
	// Try load perms for logged user
	try {
		let token = req.cookies[c.http.login.name];

		// cookie dont exists or is invalid
		if (!token || !token.match("^[a-f0-9]{40}$")) {
			throw 'Musis se <a href="/login">prihlasit</a>.';
		}
		let cookieFilePath = c.http.login.tokensPath + token + '.txt';
		// check for cookie on the server filesystem
		if (!FS.existsSync(cookieFilePath)) {
			throw 'Cookie na serveru neexistuje, musis se znovu <a href="/login">prihlasit</a>.';
		}
		// check for cookie validity on the server
		let fileStats = FS.statSync(cookieFilePath);
		if ((fileStats.atime.getTime() + c.http.login.validity) - new Date().getTime() < 0) {
			throw 'Platnost cookie vyprsela, musis se znovu <a href="/login">prihlasit</a>.';
		}

		// Everything is ok
		let cookieContent = JSON.parse(FS.readFileSync(cookieFilePath));

		res.locals.user = cookieContent.email;
		// load logged user permissions and merge with default user permissions
		userPerms = perms.getUser(cookieContent.email).concat(userPerms);

		// update cookie expiration on the server
		FS.utimesSync(cookieFilePath, new Date(), new Date());
	} catch (error) {
		res.clearCookie(c.http.login.name);
	}

	// Try load and merge perms if user has some passwords
	try {
		let passwordCookie = req.cookies['pmg-passwords'];
		if (!passwordCookie) {
			throw 'No password cookie is available';
		}
		passwordCookie.split(',').forEach(function (pass) {
			userPerms = perms.getPass(pass).concat(userPerms);
		});
	} catch (error) {
		// Do nothing, probably user just dont have cookie
	}

	// If user has master permission to root, remove all other permissions
	if (userPerms.indexOf('/') >= 0) {
		userPerms = ['/'];
	}
	res.locals.userPerms = userPerms;

	LOG.info('(Web) Api access ' + req.path + ', user "' + (req.user ? res.locals.user : 'x') + '"');

	// Parse, sanatize and check permissions for path if defined
	if (req.query.path) {
		let path = req.query.path;
		try {
			// base64 decode
			path = decodeURIComponent(Buffer.from(path, 'base64').toString());
			path = HFS.pathNormalize(path);
			res.locals.queryPath = path;

			if (perms.test(res.locals.userPerms, path) === false) {
				throw 'User do not have permissions to path"' + path + '"'; // user dont have permission to this path
			}

			let fullPath = HFS.pathJoin(c.path, path);
			// Check if path exists
			let fileStats = FS.lstatSync(fullPath); // throws exception if not exists or not accessible

			if (fullPath.match(/\/$/)) { // requested path wants folder
				if (fileStats.isDirectory()) {
					res.locals.fullPathFolder = fullPath;
				} else {
					throw 'Requested path "' + path + '" is not folder';
				}
			} else { // Requested path wants file
				if (fileStats.isFile()) {
					res.locals.fullPathFile = fullPath;
				} else {
					throw 'Requested path "' + path + '" is not file';
				}
			}
			res.locals.path = path;
		} catch (error) {
			// log to debug because anyone can generate invalid paths
			LOG.debug('(Web) Requested invalid path "' + req.query.path + '", error: ' + error + '.');
		}
	}

	next();
});

/**
 * Run user search in all files and folders
 * - case insensitive
 * - search is performed in folder, what user has loaded (param path)
 *
 * @param query - searching string
 * @param path - where to search
 */
webserver.get('/api/search', function (req, res) {
	res.statusCode = 200;
	res.setHeader("Content-Type", "application/json");
	let finds = {
		folders: [],
		files: []
	};
	try {
		if (!req.query.query) {
			throw 'Error: no search input';
		}
		if (!res.locals.fullPathFolder) {
			throw 'Error: no path';
		}

		finds.folders.push({
			path: res.locals.path,
			noFilter: true,
			displayText: 'Zavřít vyhledávání "' + req.query.query + '"',
			displayIcon: 'long-arrow-left' // icon is reserved to close searching (force reload structure)
		});
	} catch (error) {
		res.result.setError(error.toString()).end();
		return;
	}

	let logPrefix = '(Web) Searching "' + req.query.query + '" in path "' + res.locals.path + '"';
	let readDirStart = new Date();

	// @TODO update to node version 10.10.0+ to support fs.Dirent
	// https://github.com/paulmillr/readdirp/issues/95
	// https://nodejs.org/api/fs.html#fs_class_fs_dirent

	// Do not use readdirp.fileFilter option because is case sensitive.
	// Instead create custom file extensions regex with case-insensitive parameter
	// Closed github request, Option for case-insensitive filter: https://github.com/paulmillr/readdirp/issues/47
	readdirp(res.locals.fullPathFolder, {type: 'files_directories', depth: 10, alwaysStat: false}).on('data', function (entry) {
		try {
			if (entry.dirent.isFile() && !entry.basename.match(c.extensionsRegexAll)) {
				return; // file has invalid extension
			}

			let entryPath = HFS.pathNormalize(entry.fullPath, c.path);
			if (entry.basename.toLowerCase().indexOf(req.query.query.toLowerCase()) === -1) {
				return; // not match with searched query
			}

			if (perms.test(res.locals.userPerms, entryPath) === false) {
				return; // user dont have permission to this item
			}

			let pathData = {
				path: entryPath,
				displayText: entryPath
			};
			if (entry.dirent.isDirectory()) {
				pathData.path += '/';
				finds.folders.push(pathData);
			} else { // is file, load detailed info
				let pathStats = FS.lstatSync(entry.fullPath);
				pathData.size = pathStats.size;
				pathData.created = pathStats.ctime;
				finds.files.push(pathData);
			}
		} catch (error) {
			LOG.error(logPrefix + ' throwed error while processing readdirp results: ' + error);
		}
	}).on('warn', function (warning) {
		LOG.warning(logPrefix + ' throwed warning: ' + warning);
	}).on('error', function (error) {
		LOG.error(logPrefix + ' throwed error: ' + error);
	}).on('end', function () {
		let humanTime = msToHuman(new Date() - readDirStart);
		LOG.info(logPrefix + ' is done in ' + humanTime + ', founded ' + finds.folders.length + ' folders and ' + finds.files.length + ' files.');
		res.result.setResult(finds, 'Done in ' + humanTime).end();
	});
});

/**
 * Force download file instead custom headers for image, video etc.
 *
 * @returns streamed file if ok
 * @returns JSON if error
 */
webserver.get('/api/download', function (req, res) {
	res.statusCode = 200;
	try {
		if (!res.locals.fullPathFile) {
			throw 'neplatna-cesta';
		}
		res.set('Content-Disposition', 'inline;filename="' + res.locals.fullPathFile.split('/').pop() + '"');
		LOG.info('(Web) Streaming file to download: ' + res.locals.fullPathFile);
		return FS.createReadStream(res.locals.fullPathFile).pipe(res);
	} catch (error) {
		res.statusCode = 404;
		res.result.setError('soubor-neexistuje').end();
	}
});

/**
 * Check and/or update passwords
 * If no parameter is set, list of passwords and permissions to these passwords is returned
 * If parameter "password" is set and valid, save it to the cookie and returns permissions to this passwords
 *
 * @requires password (optional)
 * @returns JSON list of permissions
 */
webserver.get('/api/password', function (req, res) {
	res.setHeader("Content-Type", "application/json");
	res.statusCode = 200;
	try {
		let cookiePasswords = req.cookies['pmg-passwords'];
		// If no password parameter is set, return list of all passwords
		if (!req.query.password) {
			let passwordPerms = [];
			if (cookiePasswords) {
				cookiePasswords.split(',').forEach(function (password) {
					passwordPerms.push({
						password: password,
						permissions: perms.getPass(password)
					});
				});
			}
			res.result.setResult(passwordPerms, 'List of saved passwords.').end();
			return;
		}
		// Passsword parameter is set. Check, if there are any permission to this cookie
		let passwordPerms = perms.getPass(req.query.password);
		if (passwordPerms.length === 0) {
			throw 'Invalid password.';
		}
		// Password is valid, save it into cookie (or create it if not set before)
		if (cookiePasswords) {
			let passwordsCookie = cookiePasswords.split(',');
			if (passwordsCookie.indexOf(req.query.password) === -1) { // push to cookie only if not already pushed before
				passwordsCookie.push(req.query.password);
				res.cookie('pmg-passwords', passwordsCookie.join(','), {expires: new Date(253402300000000)});
			}
		} else {
			res.cookie('pmg-passwords', req.query.password, {expires: new Date(253402300000000)});
		}
		// return list of permissions to this password
		res.result.setResult({
			password: req.query.password,
			permissions: passwordPerms
		}, 'Password "' + req.query.password + '" is valid.');
		if (req.xhr) {
			// no redirect if ajax request
		} else if (req.query.redirect && req.query.redirect === 'false') {
			// no redirect if param redirect=false
		} else {
			// automatic redirect to the folder
			res.cookie('pmg-redirect', HFS.pathDirname(passwordPerms[0]), {expires: new Date(253402300000000)});
			res.redirect('/');
		}
	} catch (error) {
		res.result.setError(error).end();
	}
	res.result.end();
});

/**
 * Stream image.
 * Image can be compressed via cookie. This can be overriden via GET compress=true or false
 *
 * @returns image stream (in case of error, streamed image with error text)
 */
webserver.get('/api/image', function (req, res) {
	res.statusCode = 200;
	res.setHeader("Content-Type", "image/png");
	res.result.toString = function () {
		return './public/image-errors/' + this.message + '.png';
	};
	try {
		if (!res.locals.fullPathFile) {
			throw new Error('Neplatná cesta nebo nemáš právo');
		}
		let imageStream = FS.createReadStream(res.locals.fullPathFile);
		if ((req.cookies['pmg-compress'] === 'true' && req.query.compress !== 'false') || req.query.compress === 'true') {
			imageStream = imageStream.pipe(sharp().resize(c.compress));
		}
		return imageStream.pipe(res);
	} catch (error) {
		res.statusCode = 404;
		let fontSize = 40;
		let textBuffer = new Buffer(
			'<svg height="' + (fontSize) + '" width="700">' +
			'  <text x="50%" y="30" dominant-baseline="hanging" text-anchor="middle" font-size="' + fontSize + '" fill="#fff">' + error + '</text>' +
			'</svg>'
		);

		sharp({
			create: {
				width: 700,
				height: 100,
				channels: 4,
				background: { r: 220, g: 53, b: 69, }
			}
		}).composite([{ input: textBuffer}]).png().pipe(res);
	}
});

/**
 * Stream video into browser
 *
 * @Author https://medium.com/better-programming/video-stream-with-node-js-and-html5-320b3191a6b6
 * @returns video stream
 */
webserver.get('/api/video', function (req, res) {
	res.statusCode = 200;
	try {
		if (!res.locals.fullPathFile) {
			throw 'Invalid video path'
		}
		const fileSize = FS.statSync(res.locals.fullPathFile).size;
		const range = req.headers.range;
		if (range) {
			const parts = range.replace(/bytes=/, "").split("-");
			const start = parseInt(parts[0], 10);
			const end = (parts[1] ? parseInt(parts[1], 10) : fileSize - 1);
			const file = FS.createReadStream(res.locals.fullPathFile, {start, end});
			res.writeHead(206, {
				'Content-Range': `bytes ${start}-${end}/${fileSize}`,
				'Accept-Ranges': 'bytes',
				'Content-Length': (end - start) + 1, // chunk size
				'Content-Type': 'video/mp4'
			});
			file.pipe(res);
		} else {
			res.writeHead(200, {
				'Content-Length': fileSize,
				'Content-Type': 'video/mp4'
			});
			FS.createReadStream(res.locals.fullPathFile).pipe(res);
		}
	} catch (error) {
		res.statusCode = 404;
		res.result.setError('File - Zadaná cesta není platná').end();
	}
});

/**
 * Google logout
 * - remove cookie from the server (cant be used anymore)
 * - request browser to remove it from browser
 *
 * @returns JSON if ajax
 * @returns redirect otherwise
 */
webserver.get('/api/logout', function (req, res) {
	res.setHeader("Content-Type", "application/json");
	res.statusCode = 200;
	try {
		if (!res.locals.user) { // is logged (it means cookie is valid)
			throw 'Not logged in.';
		}
		let token = req.cookies[c.http.login.name];
		try {
			// remove cookie from server file
			FS.unlinkSync(c.http.login.tokensPath + token + '.txt');
		} catch (error) {
			LOG.error('Cant delete token "' + token + '". ' + error);
			throw 'Cant delete token. More info in log.';
		}
		res.result.setResult('Cookie was deleted');
	} catch (error) {
		res.result.setError(error.message || error);
	}
	res.clearCookie(c.http.login.name); // send request to browser to remove cookie
	res.result.end();
});

/**
 * Show uptime data
 *
 * @returns JSON
 */
webserver.get('/api/ping', function (req, res) {
	res.setHeader("Content-Type", "application/json");
	res.statusCode = 200;
	res.result.setResult(getUptime()).end();
});

/**
 * Save reports (errors, feedback, etc)
 *
 * @returns JSON
 */
webserver.post('/api/report', function (req, res) {
	res.setHeader("Content-Type", "application/json");
	res.statusCode = 200;
	let msg = '(Report) User "' + (res.locals.user ? res.locals.user : 'x') + '" is reporting ';
	if (req.body.type && req.body.type.match(/^[a-zA-Z0-9_\-.]{1,20}$/) && req.body.raw) {
		switch (req.body.type) {
			case 'javascript':
				LOG.error(msg += 'javascript error:\n' + req.body.raw);
				break;
			default:
				LOG.debug(msg += 'type="' + req.body.type + '":\n"' + req.body.raw + '".');
				break;
		}
		res.result.setResult(null, 'Report saved').end();
	} else {
		res.result.setError('Invalid "type" or "raw" POST data').end();
	}
});

/**
 * Kill server
 *
 * @returns JSON
 */
webserver.get('/api/kill', function (req, res) {
	res.setHeader("Content-Type", "application/json");

	if (req.query.password !== c.security.killPassword) {
		res.result.setError('Wrong password').end();
		return;
	}
	res.result.setResult(null, 'pldrGallery is going to kill in 2 seconds.').end();
	LOG.head('(Web) Server is going to kill');
	setTimeout(function () {
		process.exit();
	}, 2000);
});

/**
 * Load list items (of files and folders) from given path
 *
 * @returns JSON
 */
webserver.get('/api/structure', function (req, res) {
	res.statusCode = 200;
	res.setHeader("Content-Type", "application/json");
	if (!res.locals.fullPathFolder) {
		res.result.setError('Zadaná cesta "<b>' + res.locals.queryPath + '</b>" není platná nebo na ni nemáš právo.').end();
		return;
	}

	const globSearch = [
		res.locals.fullPathFolder + '*/',
		res.locals.fullPathFolder + '*.*',
	];

	const loadFoldersPromise = new Promise(function (resolve) {
		let folders = [];
		// if requested folder is not root add one item to go back
		if (res.locals.path !== '/') {
			folders.push({
				path: generateGoBackPath(res.locals.path),
				displayText: '..',
				noFilter: true,
				displayIcon: 'level-up',
			});
		}
		globby(globSearch[0]).then(function (rawPathsFolders) {
			rawPathsFolders.forEach(function (path) {
				try {
					let pathStats = FS.lstatSync(path);
					path = HFS.pathNormalize(path, c.path);
					if (perms.test(res.locals.userPerms, path) === false) {
						return;
					}
					if (pathStats.isDirectory()) {
						folders.push({
							path: path
						});
					}
				} catch (error) {
					LOG.debug('[Globby] Cant get stats from folder "' + path + '": ' + error.message);
				}
			});
			resolve(folders);
		});
	});

	const loadFilesPromise = new Promise(function (resolve) {

		function getCoordsFromExifFromFile(fullPath) {
			try {
				if (fullPath.match(c.extensionsRegexExif) === false)  {
					return {};
				}
				// create small buffer, fill it with first x bytes from image and parse
				let exifBuffer = new Buffer.alloc(c.exifBufferSize);
				FS.readSync(FS.openSync(fullPath, 'r'), exifBuffer, 0, c.exifBufferSize, 0);
				let parsed = exifParser.create(exifBuffer).parse();
				if (parsed.tags.GPSLatitude && parsed.tags.GPSLongitude) {
					return {
						coordLat: numberRound(parsed.tags.GPSLatitude, 6),
						coordLon: numberRound(parsed.tags.GPSLongitude, 6),
					};
				}
			} catch (error) {
				if (error.message === 'Index out of range') {
					LOG.warning(c.exifBufferSize + ' bytes is too small buffer for loading EXIF from file "' + fullPath + '".');
				} else if (error.message === 'Invalid JPEG section offset') {
					// ignore, probably broken image and/or EXIF data, more info in https://github.com/bwindels/exif-parser/issues/13
				} else {
					LOG.error('Error while loading coordinates from EXIF for file "' + fullPath + '": ' + error);
				}
			}
			return {};
		}

		let files = [];
		globby(globSearch[1], {nodir: true}).then(function (rawPathsFiles) {
			rawPathsFiles.forEach(function (fullPath) {
				try {
					const pathStats = FS.lstatSync(fullPath);
					const dynamicPath = HFS.pathNormalize(fullPath, c.path);
					if (perms.test(res.locals.userPerms, dynamicPath) === false) {
						return;
					}
					if (pathStats.isFile() && dynamicPath.match(c.extensionsRegexAll)) {
						let pathData = {
							path: dynamicPath,
							size: pathStats.size,
							created: pathStats.ctime,
						};
						// try to load coordinates from EXIF and merge them into path data
						pathData = Object.assign(pathData, getCoordsFromExifFromFile(fullPath));
						files.push(pathData);
					}
				} catch (error) {
					LOG.error('[Globby] Cant get stats from file "' + PATH + '": ' + error);
				}
			});
			return resolve(files);
		});
	});

	function generateSpecificFilePromise(filename) {
		return new Promise(function (resolve) {
			if (perms.test(res.locals.userPerms, res.locals.path + filename) === false) { // user dont have permission to this file
				return resolve(null);
			}
			FS.readFile(res.locals.fullPathFolder + filename, function (error, data) {
				if (error) {
					if (error.code !== 'ENOENT') { // some other error than just missing file
						LOG.error('Error while loading "' + res.locals.path + filename + '": ' + error)
					}
					return resolve(null)
				}
				resolve(data.toString());
			});
		});
	}

	Promise.all([
		loadFoldersPromise,
		loadFilesPromise,
		generateSpecificFilePromise('header.html'),
		generateSpecificFilePromise('footer.html'),
	]).then(function (data) {
		res.result.setResult({
			folders: data[0],
			files: data[1],
			header: data[2],
			footer: data[3]
		}).end();
	});
});

// Start webserver server
webserver.listen(c.http.port, function () {
	LOG.info('(HTTP) Server listening on port ' + c.http.port);
});
